# -*- coding: utf-8 -*-
"""Operacion BWC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UQUsU07n4jyRyIVosdu4Z4F-MLMSiylt
"""

import pandas as pd
from datetime import timedelta, datetime
from unidecode import unidecode
import unicodedata
import io
import gspread
import pytz
from gspread_dataframe import get_as_dataframe
from google.oauth2.service_account import Credentials
import streamlit as st
import json

##### MAIN #####

def guardar_df(nombre, df, spreadsheet):
    ws = spreadsheet.worksheet(nombre)
    ws.clear()
    ws.update([df.columns.values.tolist()] + df.fillna("").astype(str).values.tolist())

def limpiar_identificadores(df):
    df = df.copy()
    for col in ['msisdn', 'iccid']:
        if col in df.columns:
            df[col] = df[col].astype(str).str.lstrip("'")
    return df

def convertir_a_excel(df):
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, index=False)
    output.seek(0)
    return output

def cargar_base_operativa():
    # Autenticaci√≥n
    scopes = ["https://www.googleapis.com/auth/spreadsheets", "https://www.googleapis.com/auth/drive"]
    creds = Credentials.from_service_account_info(
    json.loads(st.secrets["GOOGLE_CREDENTIALS"]),
    scopes=scopes
    )
    client = gspread.authorize(creds)

    # Abrir archivo
    sheet = client.open("BaseOperativa")

    # Leer todas las hojas necesarias como DataFrames
    si_procede_base = get_as_dataframe(sheet.worksheet("Si procede"), dtype=str)
    no_procede_base = get_as_dataframe(sheet.worksheet("No procede"), dtype=str)
    next_renewals = get_as_dataframe(sheet.worksheet("Next Renewals"), dtype=str)
    associates_df = get_as_dataframe(sheet.worksheet("Associates"), dtype=str)
    reactivaciones_df = get_as_dataframe(sheet.worksheet("Reactivaciones"), dtype=str)
    cancelations = get_as_dataframe(sheet.worksheet("Cancelations"), dtype=str)
    billing_days = get_as_dataframe(sheet.worksheet("Day"), dtype=str)
    billing_existente = get_as_dataframe(sheet.worksheet("Billing"), dtype=str)
    activations = get_as_dataframe(sheet.worksheet("Activations"), dtype=str)
    renewals = get_as_dataframe(sheet.worksheet("Renewals"), dtype=str)

    # Retornar todo como diccionario
    return {
        "si_procede_base": si_procede_base,
        "no_procede_base": no_procede_base,
        "next_renewals": next_renewals,
        "associates_df": associates_df,
        "reactivaciones_df": reactivaciones_df,
        "cancelations": cancelations,
        "billing_days": billing_days,
        "billing_existente": billing_existente,
        "activations": activations,
        "renewals": renewals,
        "spreadsheet": sheet  # necesario para escribir cambios despu√©s
    }


###############

def buscar_linea(df, msisdn_iccid):
    df = df.copy()
    df['msisdn'] = df['msisdn'].astype(str)
    df['iccid'] = df['iccid'].astype(str)
    return df[
        (df['msisdn'] == msisdn_iccid) |
        (df['iccid'] == msisdn_iccid)
    ]

def calcular_fecha_facturacion(hoy, dia_fact):
    dias_semana = {
        "LUNES": 0, "MARTES": 1, "MIERCOLES": 2,
        "JUEVES": 3, "VIERNES": 4, "SABADO": 5, "DOMINGO": 6
    }
    target_day = dias_semana[dia_fact]
    dias_adelanto = (target_day - hoy.weekday() + 7) % 7 or 7
    if dias_adelanto < 7:
        dias_adelanto += 7
    return hoy + timedelta(days=dias_adelanto)

##### 1. Revision ######

def generar_archivo_revision(first_renewal_day):
    # === Paso 0: Cargar base operativa ===
    data = cargar_base_operativa()
    activations = data['activations']
    renewals = data['renewals']
    billing_days = data['billing_days']
    cancelations = data['cancelations']
    # === Paso 1: Preparar columnas de fechas ===
    first_renewal_day = first_renewal_day.date()# if hasattr(first_renewal_day, 'date') else first_renewal_day
    activations['fechaRenovacionServicio'] = pd.to_datetime(activations['fechaActivacion'], errors='coerce')

    combined_df = pd.concat([activations, renewals], axis=0, ignore_index=True)
    combined_df['fechaRenovacionServicio'] = pd.to_datetime(combined_df['fechaRenovacionServicio'], errors='coerce')

    combined_df['codigoDistribuidora'] = combined_df['codigoDistribuidora'].str.strip()
    billing_days['codigoDistribuidora'] = billing_days['codigoDistribuidora'].str.strip()

    combined_df = combined_df.merge(
        billing_days[['codigoDistribuidora', 'diaFacturacion']],
        on='codigoDistribuidora', how='left'
    )

    # === Paso 2: Calcular el calendario ===
    def calculate_billing_schedule(first_day):
        billing_day_inclusions = {
            0: ["LUNES"],
            1: ["LUNES", "MARTES"],
            2: ["LUNES", "MARTES", "MIERCOLES"],
            3: ["LUNES", "MARTES", "MIERCOLES", "JUEVES"],
            4: ["LUNES", "MARTES", "MIERCOLES", "JUEVES", "VIERNES"],
            5: ["LUNES", "MARTES", "MIERCOLES", "JUEVES", "VIERNES"],
            6: ["LUNES", "MARTES", "MIERCOLES", "JUEVES", "VIERNES"],
            7: ["MARTES", "MIERCOLES", "JUEVES", "VIERNES"],
            8: ["MIERCOLES", "JUEVES", "VIERNES"],
            9: ["JUEVES", "VIERNES"],
            10: ["VIERNES"],
        }

        combined_df['fechaRenovacionServicio'] = combined_df['fechaRenovacionServicio'].dt.date
        renewal_window = [first_day + timedelta(days=i) for i in range(11)]

        final_schedule = []
        for i, renewal_day in enumerate(renewal_window):
            target_date = renewal_day - timedelta(days=29)
            allowed_billing_days = billing_day_inclusions[i]

            filtered_df = combined_df[combined_df['fechaRenovacionServicio'] == target_date]

            if filtered_df.empty:
                continue

            filtered_df = filtered_df[filtered_df['diaFacturacion'].isin(allowed_billing_days)]
            filtered_df['nueva_renovacion'] = renewal_day
            final_schedule.append(filtered_df)

        return pd.concat(final_schedule, ignore_index=True) if final_schedule else pd.DataFrame()

    final_schedule = calculate_billing_schedule(first_renewal_day)

    final_schedule['diaFacturacion'] = final_schedule['diaFacturacion'].astype(str)
    lunes_anterior = first_renewal_day - timedelta(days=7)

    dias_a_fechas = {
        "LUNES": lunes_anterior,
        "MARTES": lunes_anterior + timedelta(days=1),
        "MIERCOLES": lunes_anterior + timedelta(days=2),
        "JUEVES": lunes_anterior + timedelta(days=3),
        "VIERNES": lunes_anterior + timedelta(days=4),
    }

    final_schedule['diaFacturacion'] = final_schedule['diaFacturacion'].map(dias_a_fechas)

    # === Paso 3: Eliminar cancelaciones ===
    final_schedule = final_schedule[
        ~(
            final_schedule['msisdn'].isin(cancelations['msisdn']) |
            final_schedule['iccid'].isin(cancelations['iccid'])
        )
    ]

    # === Paso 4: Formato final ===
    final_schedule = final_schedule.drop(columns=['fechaRenovacionServicio', 'fechaFacturacion'])
    final_schedule = final_schedule.rename(columns={
        'nueva_renovacion': 'fechaRenovacionServicio',
        'diaFacturacion': 'fechaFacturacion'
    })

    final_schedule = final_schedule[[
        'nombre', 'msisdn', 'iccid',
        'fechaActivacion', 'fechaRenovacionServicio',
        'fechaFacturacion', 'codigoDistribuidora'
    ]]

    final_schedule['nombre'] = final_schedule['nombre'].apply(unidecode)

    # === Paso 5: Exportar archivo como bytes para descarga en Streamlit ===
    buffer = io.BytesIO()
    with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
        final_schedule.to_excel(writer, index=False, sheet_name='Revision')
    buffer.seek(0)

    return buffer  # üëâ Se retorna como archivo descargable


######################


#### 2. Facturacion #####

def procesar_facturacion(revision_file, actualizacion_csv):
    # === Paso 0: Cargar base operativa ===
    data = cargar_base_operativa()
    si_procede_base = data['si_procede_base']
    no_procede_base = data['no_procede_base']
    next_renewals = data['next_renewals']
    associates_df = data['associates_df']
    reactivaciones_df = data['reactivaciones_df']
    billing_existente = data['billing_existente']
    spreadsheet = data['spreadsheet']

    # === Paso 1: Cargar archivos externos ===
    si_procede_df = pd.read_excel(revision_file, sheet_name="Si procede", dtype=str)
    no_procede_df = pd.read_excel(revision_file, sheet_name="No procede", dtype=str)
    actualizacion_df = pd.read_csv(actualizacion_csv, dtype=str)

    # === Paso 2: Actualizar msisdn e iccid ===
    def actualizar_msisdn_icc(df):
        actualizacion_copia = actualizacion_df[['icc', 'msisdn']].copy()
        df = df.merge(actualizacion_copia, left_on='iccid', right_on='icc', how='left', suffixes=('', '_nuevo'))
        faltantes = df['msisdn_nuevo'].isna()
        df.loc[faltantes, 'iccid'] = df.loc[faltantes, 'msisdn'].map(
            actualizacion_df.drop_duplicates('msisdn').set_index('msisdn')['icc']
        )
        df['msisdn'] = df['msisdn_nuevo'].combine_first(df['msisdn'])
        df.drop(columns=['msisdn_nuevo', 'icc'], inplace=True, errors='ignore')
        return df

    si_procede_df = actualizar_msisdn_icc(si_procede_df)
    no_procede_df = actualizar_msisdn_icc(no_procede_df)

    # === Paso 3: Preparar fechas y claves (normalizado para evitar duplicados) ===

    def normalizar(df):
        df = df.copy()
        df['msisdn'] = df['msisdn'].astype(str).str.strip().str.replace("'", "")
        df['fechaRenovacionServicio'] = pd.to_datetime(df['fechaRenovacionServicio'], errors='coerce').dt.strftime('%Y-%m-%d')
        return df

    # Normalizar tanto bases como nuevos
    si_procede_base_norm = normalizar(si_procede_base)
    si_procede_df_norm = normalizar(si_procede_df)

    no_procede_base_norm = normalizar(no_procede_base)
    no_procede_df_norm = normalizar(no_procede_df)

    # Crear claves sobre versiones normalizadas
    si_procede_base_norm['clave'] = si_procede_base_norm['msisdn'] + "_" + si_procede_base_norm['fechaRenovacionServicio']
    si_procede_df_norm['clave'] = si_procede_df_norm['msisdn'] + "_" + si_procede_df_norm['fechaRenovacionServicio']

    no_procede_base_norm['clave'] = no_procede_base_norm['msisdn'] + "_" + no_procede_base_norm['fechaRenovacionServicio']
    no_procede_df_norm['clave'] = no_procede_df_norm['msisdn'] + "_" + no_procede_df_norm['fechaRenovacionServicio']

    # Comparar claves pero mantener registros originales
    nuevos_si_procede = si_procede_df[~si_procede_df_norm['clave'].isin(si_procede_base_norm['clave'])].copy()
    nuevos_no_procede = no_procede_df[~no_procede_df_norm['clave'].isin(no_procede_base_norm['clave'])].copy()

    # Actualizar las bases uniendo solo lo nuevo
    si_procede_actualizado = pd.concat([si_procede_base, nuevos_si_procede], ignore_index=True)
    no_procede_actualizado = pd.concat([no_procede_base, nuevos_no_procede], ignore_index=True)
    # === Paso 4: Actualizar Next Renewals ===
    nsp_claves = nuevos_si_procede['msisdn'].astype(str) + "_" + nuevos_si_procede['fechaRenovacionServicio'].astype(str)
    nr_claves = next_renewals['msisdn'].astype(str) + "_" + next_renewals['fechaRenovacionServicio'].astype(str)
    nuevos_para_renewals = nuevos_si_procede[~nsp_claves.isin(nr_claves)].copy()
    next_renewals_actualizado = pd.concat([next_renewals, nuevos_para_renewals], ignore_index=True)

    # === Paso 5: Guardar actualizaciones en la base operativa ===

    guardar_df("Si procede", si_procede_actualizado, spreadsheet)
    guardar_df("No procede", no_procede_actualizado, spreadsheet)
    guardar_df("Next Renewals", next_renewals_actualizado, spreadsheet)

    # === Paso 6: Generar hoja Billing ===
    reactivaciones_df['msisdn'] = reactivaciones_df['msisdn'].astype('Int64')
    fechas_validas = nuevos_si_procede['fechaFacturacion'].dropna().unique()
    reactivaciones_df['fechaFacturacion'] = pd.to_datetime(reactivaciones_df['fechaFacturacion'], errors='coerce')
    reactivaciones_df = reactivaciones_df[reactivaciones_df['fechaFacturacion'].isin(fechas_validas)]
    facturables_df = pd.concat([nuevos_si_procede, reactivaciones_df], ignore_index=True)

    facturables_df['item'] = '97005'
    facturables_df['cantidad'] = 1
    facturables_df['cobro'] = '190'
    facturables_df['nombreAsociado'] = facturables_df['nombre']
    dias_es = {'Monday': 'Lunes', 'Tuesday': 'Martes', 'Wednesday': 'Miercoles',
               'Thursday': 'Jueves', 'Friday': 'Viernes', 'Saturday': 'S√°bado', 'Sunday': 'Domingo'}
    facturables_df['fechaFacturacion'] = pd.to_datetime(facturables_df['fechaFacturacion'], errors='coerce')
    facturables_df['diaFacturacion'] = facturables_df['fechaFacturacion'].dt.day_name().map(dias_es)

    facturables_df = facturables_df.merge(
        associates_df[['codigoDistribuidora', 'idAsociado']], on='codigoDistribuidora', how='left'
    )

    billing_df = facturables_df[[
        'codigoDistribuidora', 'msisdn', 'nombre', 'idAsociado', 'nombreAsociado',
        'diaFacturacion', 'item', 'cantidad', 'cobro', 'iccid',
        'fechaActivacion', 'fechaRenovacionServicio', 'fechaFacturacion'
    ]].drop_duplicates(subset=['msisdn', 'fechaRenovacionServicio'])

    # === Paso 7: Guardar nueva hoja Billing en la base ===
    billing_final = pd.concat([billing_existente, billing_df], ignore_index=True)
    guardar_df("Billing", billing_final, spreadsheet)

    return billing_df  # üëâ Puedes mostrarlo en Streamlit si quieres



###################### Activaciones #########

def actualizar_activaciones(ventas_file):
    # === Paso 0: Cargar base operativa desde Google Sheets ===
    data = cargar_base_operativa()
    activaciones_base = data['activations']
    associates_df = data['associates_df']
    spreadsheet = data['spreadsheet']
    # === Paso 1: Leer archivo de ventas ===
    ventas_excel = pd.ExcelFile(ventas_file)
    total = ventas_excel.parse("activacionesTotales", dtype=str)
    ventas = ventas_excel.parse("ventasTotales", dtype=str)

    # Convertir fechaActivacion
    total['fechaActivacion'] = pd.to_datetime(total['fechaActivacion'], errors='coerce', dayfirst=True)
    activaciones_base['fechaActivacion'] = pd.to_datetime(activaciones_base['fechaActivacion'], errors='coerce')


    # Filtrar nuevas activaciones
    ultima_fecha = activaciones_base['fechaActivacion'].max()
    nuevas_activaciones = total[total['fechaActivacion'] > ultima_fecha].copy()

    # Merge con ventas
    ventas_min = ventas[['msisdn', 'nombreDistribuidora', 'distribuidora']]
    nuevas_activaciones = nuevas_activaciones.merge(ventas_min, on='msisdn', how='left')
    nuevas_activaciones = nuevas_activaciones.rename(columns={
        'icc': 'iccid',
        'nombreDistribuidora': 'nombre',
        'distribuidora': 'codigoDistribuidora'
    })

    nuevas_activaciones = nuevas_activaciones[[
        'nombre', 'msisdn', 'iccid', 'fechaActivacion', 'codigoDistribuidora'
    ]]

    # Eliminar acentos
    def clean_text(text):
        if isinstance(text, str):
            return unicodedata.normalize('NFKD', text).encode('ASCII', 'ignore').decode('utf-8')
        return text

    nuevas_activaciones = nuevas_activaciones.applymap(clean_text)
    activaciones_base = activaciones_base.applymap(clean_text)

    # Actualizar hoja Activations
    activaciones_actualizado = pd.concat([activaciones_base, nuevas_activaciones], ignore_index=True)

    # === Paso 2: Actualizar hoja Associates si hay nuevos DS ===
    ventas_asociados = ventas[['distribuidora', 'asociado']].drop_duplicates().rename(columns={
        'asociado': 'idAsociado',
        'distribuidora': 'codigoDistribuidora'
    })

    codigos_existentes = associates_df['codigoDistribuidora'].astype(str).unique()
    nuevos_ds = ventas_asociados[~ventas_asociados['codigoDistribuidora'].astype(str).isin(codigos_existentes)]
    associates_actualizado = pd.concat([associates_df, nuevos_ds], ignore_index=True)

    # === Paso 3: Actualizar hoja Day si hay nuevos c√≥digos ===
    day_df = data['billing_days']
    ventas_fechas = ventas[['distribuidora', 'msisdn', 'fechaVenta']].copy()
    ventas_fechas['fechaVenta'] = pd.to_datetime(ventas_fechas['fechaVenta'], errors='coerce', dayfirst=True)
    ventas_fechas = ventas_fechas.dropna(subset=['fechaVenta'])

    primeras_fechas = ventas_fechas.sort_values('fechaVenta').drop_duplicates(
        subset='distribuidora', keep='first'
    ).rename(columns={'distribuidora': 'codigoDistribuidora'})

    day_map = {
        'Monday': 'LUNES', 'Tuesday': 'MARTES', 'Wednesday': 'MIERCOLES',
        'Thursday': 'JUEVES', 'Friday': 'VIERNES', 'Saturday': 'SABADO', 'Sunday': 'DOMINGO'
    }
    primeras_fechas['diaFacturacion'] = primeras_fechas['fechaVenta'].dt.day_name().map(day_map)
    nuevos_day = primeras_fechas[['codigoDistribuidora', 'diaFacturacion']]

    codigos_day_existentes = day_df['codigoDistribuidora'].astype(str).unique()
    nuevos_day = nuevos_day[~nuevos_day['codigoDistribuidora'].astype(str).isin(codigos_day_existentes)]
    day_actualizado = pd.concat([day_df, nuevos_day], ignore_index=True)

    # === Paso final: Escribir todo de vuelta en la base de Google Sheets ===
    guardar_df("Activations", activaciones_actualizado, spreadsheet)
    guardar_df("Associates", associates_actualizado, spreadsheet)
    guardar_df("Day", day_actualizado, spreadsheet)


########### RECARGAS DIARIAS #######

def procesar_recargas_dia(fecha_deseada):
    # === Paso 0: Cargar base operativa desde Google Sheets ===
    data = cargar_base_operativa()
    next_renewals = data['next_renewals']
    renewals = data['renewals']
    cancelations = data['cancelations']
    spreadsheet = data['spreadsheet']

    # === Paso 1: Convertir fecha a datetime con zona horaria local ===
    zona_mx = pytz.timezone("America/Mexico_City")
    fecha_objetivo = pd.to_datetime(zona_mx.localize(datetime.combine(fecha_deseada, datetime.min.time())))

    # === Paso 2: Eliminar l√≠neas canceladas (por msisdn o iccid) ===
    cancelados_msisdn = cancelations['msisdn'].dropna().astype(str).unique()
    cancelados_iccid = cancelations['iccid'].dropna().astype(str).unique()

    next_renewals = next_renewals[
        ~(
            next_renewals['msisdn'].astype(str).isin(cancelados_msisdn) |
            next_renewals['iccid'].astype(str).isin(cancelados_iccid)
        )
    ]

    # === Paso 3: Filtrar las que se deben recargar ese d√≠a ===
    next_renewals['fechaRenovacionServicio'] = pd.to_datetime(next_renewals['fechaRenovacionServicio'], errors='coerce')
    recargas_hoy = next_renewals[
        next_renewals['fechaRenovacionServicio'].dt.date == fecha_objetivo.date()
    ].copy()

    # === Paso 4: Agregar a Renewals ===
    renewals_actualizado = pd.concat([renewals, recargas_hoy], ignore_index=True).drop_duplicates()

    # === Paso 5: Eliminar de Next Renewals ===
    next_renewals_filtrado = next_renewals.merge(
        recargas_hoy[['msisdn', 'iccid', 'fechaRenovacionServicio']],
        on=['msisdn', 'iccid', 'fechaRenovacionServicio'],
        how='left',
        indicator=True
    ).query('_merge == "left_only"').drop(columns='_merge')

    # === Paso 6: Guardar cambios en la base ===
    guardar_df("Renewals", renewals_actualizado, spreadsheet)
    guardar_df("Next Renewals", next_renewals_filtrado, spreadsheet)

    # === Paso 7: Preparar archivo de salida ===
    nombre_archivo = f"Recargas_diarias_{fecha_objetivo.date()}.xlsx"
    df_salida = recargas_hoy[['iccid', 'msisdn']].rename(columns={'iccid': 'icc_id'})

    return nombre_archivo, df_salida


######## CANCELACIONES ####
def cancelar_linea(identificador):
    # === Paso 0: Cargar base operativa desde Google Sheets ===
    data = cargar_base_operativa()
    next_renewals_df = data['next_renewals']
    si_procede_df = data['si_procede_base']
    no_procede_df = data['no_procede_base']
    activaciones_df = data['activations']
    cancelaciones_df = data['cancelations']
    spreadsheet = data['spreadsheet']

    # === Zona horaria local (CDMX) ===
    zona_mx = pytz.timezone("America/Mexico_City")
    hoy = pd.to_datetime(datetime.now(zona_mx).date())

    # === Funci√≥n para buscar en una hoja ===
    def buscar(df):
        df = df.copy()
        df['msisdn'] = df['msisdn'].astype(str)
        df['iccid'] = df['iccid'].astype(str)
        return df[
            (df['msisdn'] == identificador) |
            (df['iccid'] == identificador)
        ]

    # === Buscar en orden ===
    fuentes = [next_renewals_df, si_procede_df, no_procede_df, activaciones_df]
    registro = pd.DataFrame()

    for fuente in fuentes:
        encontrado = buscar(fuente)
        if not encontrado.empty:
            registro = encontrado.iloc[[-1]]  # √∫ltimo match si hay varios
            break

    # === Procesar resultado ===
    if registro.empty:
        return {"status": "error", "mensaje": "‚ùå No se encontr√≥ el identificador."}
    else:
        registro['fechaCancelacion'] = hoy
        columnas_finales = ['nombre', 'msisdn', 'iccid', 'fechaCancelacion', 'codigoDistribuidora']
        registro = registro[columnas_finales]

        # Formatear como texto limpio

        cancelaciones_actualizado = pd.concat([cancelaciones_df, registro], ignore_index=True)
        guardar_df("Cancelations", cancelaciones_actualizado, spreadsheet)

        nombre = registro.iloc[0]["nombre"]
        return {"status": "ok", "mensaje": f"‚úÖ Cancelaci√≥n registrada para {nombre}."}


########## REACTIVACIONES ########
def reactivar_linea(msisdn_iccid, codigo_input, fecha_reactivacion_input):
    # === Paso 0: Cargar base operativa ===
    data = cargar_base_operativa()
    np_df = data["no_procede_base"]
    cancelaciones_df = data["cancelations"]
    renewals_df = data["renewals"]
    asociados_df = data["associates_df"]
    day_df = data["billing_days"]
    reactivaciones_df = data["reactivaciones_df"]
    spreadsheet = data["spreadsheet"]

    # === Zona horaria local (CDMX) y hoy ===
    zona_mx = pytz.timezone("America/Mexico_City")
    hoy = pd.to_datetime(datetime.now(zona_mx).date())

    fecha_reactivacion = pd.to_datetime(fecha_reactivacion_input, format="%Y-%m-%d")

    # === Funci√≥n para buscar l√≠nea ===
    def buscar_linea(df):
        df = df.copy()
        df['msisdn'] = df['msisdn'].astype(str)
        df['iccid'] = df['iccid'].astype(str)
        return df[
            (df['msisdn'] == msisdn_iccid) |
            (df['iccid'] == msisdn_iccid)
        ]

    # === Paso 1: Buscar l√≠nea ===
    registro = buscar_linea(np_df)
    if registro.empty:
        registro = buscar_linea(cancelaciones_df)

    if not registro.empty:
        registro = registro.iloc[[-1]].copy()
        msisdn = registro['msisdn'].values[0]
        iccid = registro['iccid'].values[0]
        nombre = registro['nombre'].values[0]
        codigo_encontrado = str(registro['codigoDistribuidora'].values[0])

        if codigo_input != codigo_encontrado:
            cambio = input(f"‚ö†Ô∏è El c√≥digo ingresado ({codigo_input}) no coincide con el encontrado ({codigo_encontrado}). ¬øEs cambio de DS? (s/n): ").strip().lower()
            if cambio != "s":
                raise Exception("‚ùå Registro cancelado por discrepancia en c√≥digo de distribuidora.")
            codigo_distribuidora = codigo_input
        else:
            codigo_distribuidora = codigo_encontrado
    else:
        print("üîç L√≠nea nueva. Se solicitar√° al usuario la informaci√≥n.")
        nombre = input("Nombre del cliente: ").strip()
        msisdn = input("MSISDN: ").strip()
        iccid = input("ICCID: ").strip()
        codigo_distribuidora = codigo_input

    # === Paso 2: Verificar en Associates ===
    if codigo_distribuidora not in asociados_df['codigoDistribuidora'].astype(str).values:
        id_asociado = input("Nuevo c√≥digo detectado. Ingresa el ID del asociado: ").strip()
        asociados_df = pd.concat([asociados_df, pd.DataFrame([{
            'codigoDistribuidora': codigo_distribuidora,
            'idAsociado': id_asociado
        }])], ignore_index=True)
    else:
        id_asociado = asociados_df[asociados_df['codigoDistribuidora'].astype(str) == codigo_distribuidora]['idAsociado'].values[0]

    # === Paso 3: Verificar en Day ===
    if codigo_distribuidora not in day_df['codigoDistribuidora'].astype(str).values:
        print("C√≥digo no encontrado en hoja Day.")
        dias_validos = ["LUNES", "MARTES", "MIERCOLES", "JUEVES", "VIERNES"]
        while True:
            dia_fact = input("¬øQu√© d√≠a se factura esta DS? (Ej. LUNES, CAPS sin acentos): ").strip().upper()
            if dia_fact in dias_validos:
                break
            print("D√≠a inv√°lido. Intenta nuevamente.")
        day_df = pd.concat([day_df, pd.DataFrame([{
            'codigoDistribuidora': codigo_distribuidora,
            'diaFacturacion': dia_fact
        }])], ignore_index=True)
    else:
        dia_fact = day_df[day_df['codigoDistribuidora'].astype(str) == codigo_distribuidora]['diaFacturacion'].values[0]

    # === Paso 4: Calcular fecha de facturaci√≥n con al menos 7 d√≠as de adelanto ===
    dias_semana = {
        "LUNES": 0, "MARTES": 1, "MIERCOLES": 2,
        "JUEVES": 3, "VIERNES": 4, "SABADO": 5, "DOMINGO": 6
    }
    target_day = dias_semana[dia_fact]
    dias_adelanto = (target_day - hoy.weekday() + 7) % 7
    dias_adelanto = dias_adelanto or 7
    if dias_adelanto < 7:
        dias_adelanto += 7
    fecha_facturacion = hoy + timedelta(days=dias_adelanto)

    # === Paso 5: Eliminar de Cancelations si estaba ah√≠ ===
    cancelaciones_df = cancelaciones_df[
        ~(cancelaciones_df['msisdn'].astype(str) == msisdn) &
        ~(cancelaciones_df['iccid'].astype(str) == iccid)
    ]

    # === Paso 6: Crear registro final ===
    reactivacion_row = pd.DataFrame([{
        'nombre': nombre,
        'msisdn': msisdn,
        'iccid': iccid,
        'fechaActivacion': registro['fechaActivacion'].values[0] if not registro.empty and 'fechaActivacion' in registro.columns else fecha_reactivacion,
        'fechaRenovacionServicio': fecha_reactivacion,
        'fechaFacturacion': fecha_facturacion,
        'codigoDistribuidora': codigo_distribuidora
    }])

    # === Paso 6.1: Verificar reactivaciones previas recientes ===
    msisdn_comparacion = msisdn
    reactivaciones_previas = reactivaciones_df[
        reactivaciones_df['msisdn'].astype(str) == msisdn_comparacion
    ]

    if not reactivaciones_previas.empty:
        reactivaciones_previas['fechaRenovacionServicio'] = pd.to_datetime(
            reactivaciones_previas['fechaRenovacionServicio'].astype(str).str.replace("'", ""),
            errors='coerce'
        )
        ultima_fecha = reactivaciones_previas['fechaRenovacionServicio'].max()
        if pd.notnull(ultima_fecha):
            dias_diferencia = (hoy - ultima_fecha).days
            if dias_diferencia < 30:
                confirmar = input(f"‚ö†Ô∏è Esta l√≠nea ya fue reactivada el {ultima_fecha.date()} ({dias_diferencia} d√≠as atr√°s). ¬øRegistrar de todos modos? (s/n): ").strip().lower()
                if confirmar != "s":
                    print("‚ùå Registro cancelado.")
                    return

    # === Paso 7: Guardar ===
    renewals_df = pd.concat([renewals_df, reactivacion_row], ignore_index=True)
    reactivaciones_df = pd.concat([reactivaciones_df, reactivacion_row], ignore_index=True)

    guardar_df("Renewals", renewals_df, spreadsheet)
    guardar_df("Reactivaciones", reactivaciones_df, spreadsheet)
    guardar_df("Cancelations", cancelaciones_df, spreadsheet)
    guardar_df("Day", day_df, spreadsheet)
    guardar_df("Associates", asociados_df, spreadsheet)

    print("‚úÖ Reactivaci√≥n registrada correctamente.")

###### FUNCION DE COLNSULTA ######
def consultar_linea(identificador):
    data = cargar_base_operativa()
    resultados = {}
    hojas_a_buscar = [
        ("Si procede", data['si_procede_base']),
        ("No procede", data['no_procede_base']),
        ("Next Renewals", data['next_renewals']),
        ("Reactivaciones", data['reactivaciones_df']),
        ("Cancelations", data['cancelations']),
        ("Renewals", data['renewals']),
        ("Activations", data['activations']),
        ("Billing", data['billing_existente']),
    ]

    for nombre_hoja, df in hojas_a_buscar:
        columnas = df.columns.str.lower()
        if 'msisdn' not in columnas or 'iccid' not in columnas:
            continue

        df = df.copy()
        df.columns = columnas  # asegura que est√© en min√∫sculas por si acaso
        df['msisdn'] = df['msisdn'].astype(str)
        df['iccid'] = df['iccid'].astype(str)

        encontrados = df[(df['msisdn'] == identificador) | (df['iccid'] == identificador)]
        if not encontrados.empty:
            resultados[nombre_hoja] = encontrados.iloc[[-1]]  # el √∫ltimo que aparece en la hoja

    return resultados
